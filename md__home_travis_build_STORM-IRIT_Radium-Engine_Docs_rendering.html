<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Radium Engine: Radium Engine default rendering information</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSsymbols.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Radium Engine
   &#160;<span id="projectnumber">cfaf279965857219995329eb5963f4bb9bd4609e</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md__home_travis_build_STORM-IRIT_Radium-Engine_Docs_rendering.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Radium Engine default rendering information </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>TODO : update this documentation wrt the new rendering algorithm</b></p>
<p><em>See ./material.md "Material management in the Radium Engine" documentation for understanding what is a render technique and how it inter-operates with geometry, material and shader.</em></p>
<h2>Main render method</h2>
<p>The <code>render</code> method cannot be modified, it always does the following stuff</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void Renderer::render( const ViewingParameters&amp; data )</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  // 0. Save an eventual already bound FBO</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  saveExternalFBOInternal();</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  // 1. Gather render objects and update them</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  renderObjects = m_engine-&gt;getRenderObjectManager()-&gt;getRenderObjects();</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  updateRenderObjectsInternal( data, renderObjects );</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  // 2. Feed render queues</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  feedRenderQueuesInternal( data, renderObjects );</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  // 3. Do picking if needed</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  if ( !m_pickingQueries.empty() )</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  {</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    doPicking();</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;  }</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  // 4. Do the rendering.</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;  renderInternal( data );</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  // 5. Post processing</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;  postProcessInternal( data );</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  // 6. Write final texture to framebuffer / backbuffer</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  // (depending on wether anything was saved on step 0. or not)</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  drawScreenInternal();</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;}</div></div><!-- fragment --><h3>0. Save an eventual already bound FBO</h3>
<p>In some cases (like with <code>QtOpenGLWidget</code>), you do not draw directly on the screen, but you have instead to feed an already bound FBO. Since the default renderer uses multiple FBOs, the Qt's one must be saved.</p>
<p><em>This behaviour cannot be modified.</em></p>
<h3>1. Gather render objects and update them</h3>
<p>This construct the set of objects that must be drawn for the current frame and update their OpenGL state</p>
<h3>2. Feed the render queue</h3>
<p>This construct the set of render actions that must be done for the current frame.</p>
<h3>3. Do picking if needed</h3>
<p>If there has been some picking requests since the last frame, <code>doPicking</code> is called. This function just renders all the objects (except <em>debug</em> ones) by drawing them in some color given the ID of the entity a render object is attached to.</p>
<p>Then, for each picking request done, <code>glReadPixels</code> is called at the requested location, and object ID is retrieved.</p>
<h3>4. Do the rendering</h3>
<p>This method does most of the whole rendering work and outputs one final <em>render pass</em> texture, ready to be post-processed.</p>
<p>The main renderer of Radium, implemented in the class <code>ForwardRenderer</code> implements a Z-pre-pass forward rendering loop. Even if the material association to a drawable object, realized by the so called <code>RenderTechnique</code> is tightly coupled with the main rendering loop, Plugins might define new renderer and interact differently with shader and materials properties. See the material chapter of the documentation.</p>
<p>Here is a summary of all the draw calls </p><h4>1. Depth, ambient color and "deferred info" pass</h4>
<p>This pass</p><ul>
<li>only concerns opaque objects AND opaque fragment on transparent objects. It is used to, mainly to fill in the Z-buffer, allowing to activate early z-test for next passes since the depth buffer is already filled,</li>
<li>initialize the color buffer by computing e.g. the ambient color for each object,</li>
<li>generate several pictures of the scene allowing to implement composition effects later :<ul>
<li>saves the world-space normals for each object,</li>
<li>saves the "Diffuse" aspect of the object,</li>
<li>saves the "Specular" aspect of the object.</li>
</ul>
</li>
</ul>
<p>In this pass, each <code>RenderObject</code>is drawn with the <code>RenderTechnique::Z_PREPASS</code> argument so that the corresponding shader will be activated before draw call. (<code>ro-&gt;render( renderParameters, viewingParameters, RenderTechnique::Z_PREPASS );</code>)</p>
<p>Note that the shader associated to the <code>RenderTechnique::Z_PREPASS</code> pass must draw only fully opaque fragments. Fully transparent ones (rejected by a masking information such as mask texture) and blend-able ones (those with an opacity factor alpha les than one) must be discarded.</p>
<h4>2. Lighting pass</h4>
<p>This pass is a classic forward lighting pass that accumulates the color of each light source. Before this pass, blending (one, one) is enabled and it does </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;for each light do</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  Get light parameters</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  for each object</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    bind shader</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    bind material &amp; light</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    render mesh</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  done</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;done</div></div><!-- fragment --><p>In this pass, each <code>RenderObject</code>is drawn with the <code>RenderTechnique::LIGHTING_OPAQUE</code> argument so that the corresponding shader will be activated before draw call. (<code>ro-&gt;render( renderParameters, viewingParameters, RenderTechnique::LIGHTING_OPAQUE );</code>)</p>
<p>Note that the shader associated to the <code>RenderTechnique::LIGHTING_OPAQUE</code> pass must lit and draw only fully opaque fragments. Fully transparent ones (rejected by a masking information such as mask texture) and blend-able ones (those with an opacity factor alpha les than one) must be discarded.</p>
<h4>3. Ordered independent transparency</h4>
<p>Rendering transparent objects in Radium is done according to the algorithm described in</p><ul>
<li>Weighted Blended Order-Independent Transparency, Morgan McGuire, Louis Bavoil - NVIDIA, Journal of Computer Graphics Techniques (JCGT), vol. 2, no. 2, 122-141, 2013, <a href="http://jcgt.org/published/0002/02/09/">http://jcgt.org/published/0002/02/09/</a></li>
</ul>
<p>This pass contains one scene rendering pass and one composition pass.</p>
<ul>
<li>The scene rendering pass must compute both the accumulation buffer and the coverage buffer as described in the paper (see the Material documentation for example of shader.). It is realized the same way than the lighting pass but only fragments that are transparent must be lit and drawn.</li>
<li>The composition pass then adds to the color buffer the resulting blended color.</li>
</ul>
<h4>4. Post-process the whole <em>render pass</em></h4>
<p>This pass takes the color buffer, representing colors in linear RGB space) and apply gamma correction to the image</p>
<h4>5. Debug and <a class="el" href="namespaceUI.html">UI</a> render objects</h4>
<p>Those objects are drawn with their own shader, and without lighting. They do not write in the depth map but they have different depth testing behaviour :</p><ul>
<li>func is LESS for debug objects (drawn only if visible)</li>
<li>func is ALWAYS for <a class="el" href="namespaceUI.html">UI</a> objects (drawn in front of everything else)</li>
</ul>
<h3>6. Write final texture to framebuffer / backbuffer</h3>
<p>This method is just responsible for displaying the final stuff on screen or on the saved FBO.</p>
<h2>General information</h2>
<ul>
<li>Only two methods can be overridden for the renderer, renderInternal (step 4) and postProcessInternal (step 5).</li>
</ul>
<h2>TODO</h2>
<ul>
<li>Ambient occlusion</li>
<li>Shadow mapping</li>
<li>Skybox</li>
<li>Reflection / refraction</li>
<li>Tonemapping (only gamma correction is applied for now)</li>
<li>Bloom</li>
<li>Motion blur</li>
<li>FOV</li>
<li>Physically based rendering </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Sep 27 2019 09:50:35 for Radium Engine by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
